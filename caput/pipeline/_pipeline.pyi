from collections.abc import Generator, Sequence
from os import PathLike
from queue import Queue
from typing import Any, Literal

from .. import config

__all__ = ["Manager", "Task", "local_tasks"]

local_tasks: dict

class _PipelineMissingData(Exception): ...
class _PipelineFinished(Exception): ...

class Manager(config.Reader):
    logging: dict[str, str]
    task_specs: list
    key_pattern: str
    interactive: bool
    enable_breakpoints: bool
    versions: list
    save_config: bool

    tasks: list
    all_params: list
    all_tasks_params: list
    _psutil_profiling: bool
    key_match: str

    def __init__(self, psutil_profiling: bool = False) -> None: ...
    @classmethod
    def from_yaml_file(
        cls, file_name: PathLike, lint: bool = False, psutil_profiling: bool = False
    ) -> Manager: ...
    @classmethod
    def from_yaml_str(
        cls, yaml_doc: str, lint: bool = False, psutil_profiling: bool = False
    ) -> Manager: ...
    def _setup_logging(self, lint: bool = False) -> None: ...
    def run(self) -> None: ...
    _task_head: int
    _task_idx: int
    def runner(self) -> Generator: ...
    def _next_task(self) -> Task: ...
    def _iter_tasks(self) -> Task: ...
    @staticmethod
    def _check_task_output(out: Any | None, task: Task) -> Any | tuple[Any] | None: ...
    def _setup_tasks(self) -> None: ...
    def _validate_task_inputs(self) -> None: ...
    def _get_task_from_spec(self, task_spec: dict) -> Task: ...
    def add_task(self, task: Task, task_spec: dict = {}, **kwargs: dict) -> None: ...

class Task(config.Reader):
    broadcast_inputs: bool
    limit_outputs: int
    base_priority: int
    breakpoint: bool
    #
    def __init__(self) -> None: ...
    def setup(self, requires: Any | None = None) -> None: ...
    def validate(self) -> None: ...
    def next(self, input: Any | None = None) -> Any | None: ...
    def finish(self) -> Any | None: ...
    #
    @property
    def embarrassingly_parallelizable(self) -> bool: ...
    @property
    def cacheable(self) -> bool: ...
    def __str__(self) -> str: ...
    @property
    def _pipeline_is_available(self) -> bool: ...
    @property
    def _pipeline_priority(self) -> int | float: ...
    @property
    def mem_used(self) -> int: ...
    #
    @classmethod
    def _from_config(cls, config: dict) -> Task: ...
    _requires_keys: list[str] | tuple[str, ...] | None
    _requires: list[Any]
    _in_keys: list[str] | tuple[str, ...] | None
    _in: list[Queue]
    _out_keys: list[str] | tuple[str, ...] | None
    _num_iters: int
    def _setup_keys(
        self,
        in_: Sequence[str] | str | None = None,
        out: Sequence[str] | str | None = None,
        requires: Sequence[str] | str | None = None,
    ) -> None: ...
    _pipeline_state: Literal["setup", "next", "finish", "raise"]
    def _pipeline_advance_state(self) -> None: ...
    def _pipeline_next(self) -> Any | None: ...
    def _pipeline_queue_product(self, key: str, product: Any) -> None: ...
