from __future__ import annotations

from collections.abc import Callable, Iterator, Mapping, Sequence
from logging import Logger
from os import PathLike
from typing import Any, ClassVar, Literal, TypeVar

import h5py
import numpy as np
import numpy.typing as npt
import zarr
from _typeshed import Incomplete
from mpi4py import MPI as MPI

from ..mpiarray import MPIArray, SelectionLike
from .fileformats import FileFormat

logger: Logger
zarr_available: bool

GroupLike = TypeVar(
    "GroupLike",
    bound=type["MemGroup"] | type["MemDiskGroup"] | type[h5py.Group] | type[zarr.Group],
)
FileLike = TypeVar("FileLike", bound=type[h5py.File] | type[zarr.Group] | str | bytes)
FileOrGroupLike = TypeVar("FileOrGroupLike", bound=GroupLike | FileLike)
DatasetLike = TypeVar(
    "DatasetLike", bound=type["MemDataset"] | type[h5py.Dataset] | type[zarr.Array]
)
AttributesLike = Mapping

#
class ro_dict(Mapping):
    _dict: dict
    def __init__(self, d: Mapping | None = None) -> None: ...
    def __getitem__(self, key: Any) -> Any: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator: ...
    def __eq__(self, other: Any) -> bool: ...

#
class _Storage(dict):
    _attrs: AttributesLike
    def __init__(self, **kwargs: Any) -> None: ...
    @property
    def attrs(self) -> MemAttrs: ...
    def __eq__(self, other: Any) -> bool: ...

#
class _StorageRoot(_Storage):
    _comm: MPI.Comm | None
    _distributed: bool
    def __init__(
        self, distributed: bool = False, comm: MPI.Comm | None = None
    ) -> None: ...
    @property
    def comm(self) -> MPI.Comm | None: ...
    @property
    def distributed(self) -> bool: ...
    def __getitem__(self, key: Any) -> Any: ...
    def __eq__(self, other: Any) -> bool: ...

#
class MemAttrs(dict): ...

#
class _MemObjMixin:
    @property
    def _group_class(self) -> None: ...
    _storage_root: _StorageRoot | None
    _name: str
    def __init__(
        self, storage_root: _StorageRoot | None = None, name: str = ""
    ) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def parent(self) -> GroupLike | None: ...
    @property
    def file(self) -> GroupLike | None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __neq__(self, other: Any) -> bool: ...

#
class _BaseGroup(_MemObjMixin, Mapping):
    @property
    def _group_class(self) -> GroupLike: ...
    @property
    def comm(self) -> MPI.Comm | None: ...
    @property
    def distributed(self) -> bool: ...
    @property
    def attrs(self) -> MemAttrs: ...
    @classmethod
    def _from_storage_root(cls, storage_root: _StorageRoot, name: str) -> GroupLike: ...
    def _get_storage(self): ...
    def __getitem__(self, name: str) -> DatasetLike | GroupLike: ...
    def __delitem__(self, name: str) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[str]: ...
    def require_dataset(
        self, name: str, shape: tuple, dtype: npt.DTypeLike, **kwargs: dict
    ) -> DatasetLike: ...
    def require_group(self, name: str) -> GroupLike: ...

class MemGroup(_BaseGroup):
    def __init__(
        self, distributed: bool = False, comm: MPI.Comm | None = None
    ) -> None: ...
    @property
    def mode(self) -> Literal["r+"]: ...
    @classmethod
    def from_group(cls, group: FileOrGroupLike) -> MemGroup: ...
    @classmethod
    def from_hdf5(
        cls,
        filename: PathLike,
        distributed: bool = False,
        hints: bool = True,
        comm: MPI.Comm | None = None,
        selections: dict = {},
        convert_dataset_strings: bool = False,
        convert_attribute_strings: bool = True,
        **kwargs: Any,
    ) -> MemGroup: ...
    @classmethod
    def from_file(
        cls,
        filename: PathLike,
        distributed: bool = False,
        hints: bool = True,
        comm: MPI.Comm | None = None,
        selections: dict = {},
        convert_dataset_strings: bool = False,
        convert_attribute_strings: bool = True,
        file_format: FileFormat | None = None,
        **kwargs: Any,
    ) -> MemGroup: ...
    def to_hdf5(
        self,
        filename: PathLike,
        mode: str = "w",
        hints: bool = True,
        convert_attribute_strings: bool = True,
        convert_dataset_strings: bool = False,
        **kwargs: Any,
    ) -> None: ...
    def to_file(
        self,
        filename: PathLike,
        mode: str = "w",
        hints: bool = True,
        convert_attribute_strings: bool = True,
        convert_dataset_strings: bool = False,
        file_format: FileFormat | None = None,
        **kwargs: Any,
    ) -> None: ...
    def create_group(self, name: str) -> MemGroup: ...
    def create_dataset(
        self,
        name: str,
        shape: tuple[int, ...] | None = None,
        dtype: npt.DTypeLike | None = None,
        data: npt.ArrayLike | None = None,
        distributed: bool = False,
        distributed_axis: int | None = None,
        chunks: tuple | None = None,
        compression: str | int | None = None,
        compression_opts: dict | None = None,
        **kwargs: Any,
    ) -> MemDataset: ...
    def dataset_common_to_distributed(
        self, name: str, distributed_axis: int = 0
    ) -> MemDatasetDistributed: ...
    def dataset_distributed_to_common(self, name: str) -> MemDatasetCommon: ...

#
class MemDataset(_MemObjMixin):
    _attrs: MemAttrs
    def __init__(self, **kwargs: Any) -> None: ...
    @property
    def _group_class(self) -> MemGroup: ...
    def copy(
        self, order: Literal["C", "F", "A", "K"] = "A", shallow: bool = False
    ) -> MemDataset: ...
    def __deepcopy__(self, memo, /) -> MemDataset: ...
    def view(self) -> MemDataset: ...
    @property
    def attrs(self) -> MemAttrs: ...
    def resize(self) -> MemDataset: ...
    @property
    def shape(self) -> tuple: ...
    @property
    def dtype(self) -> np.dtype: ...
    @property
    def chunks(self) -> tuple | None: ...
    @property
    def compression(self) -> str | int | None: ...
    @property
    def compression_opts(self) -> dict | None: ...
    def __getitem__(self, obj: Any) -> Any: ...
    def __setitem__(self, obj: Any, val: Any) -> None: ...
    def __len__(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...

#
class MemDatasetCommon(MemDataset):
    _data: np.ndarray
    _chunks: tuple[int, ...] | None
    _compression: str | int | None
    _compression_opts: ClassVar[dict | None]
    def __init__(
        self,
        shape: tuple[int, ...],
        dtype: npt.DTypeLike,
        chunks: tuple[int, ...] | None = None,
        compression: str | int | None = None,
        compression_opts: dict | None = None,
        **kwargs: dict,
    ) -> None: ...
    @classmethod
    def from_numpy_array(
        cls,
        data: npt.NDArray,
        chunks: tuple[int, ...] | None = None,
        compression: str | int | None = None,
        compression_opts: dict | None = None,
        **kwargs: dict,
    ) -> MemDatasetCommon: ...
    @property
    def comm(self) -> None: ...
    @property
    def common(self) -> Literal[True]: ...
    @property
    def distributed(self) -> Literal[False]: ...
    @property
    def data(self) -> np.ndarray: ...
    @property
    def local_data(self) -> np.ndarray: ...
    @property
    def shape(self) -> tuple[int, ...]: ...
    @property
    def dtype(self) -> np.dtype: ...
    @property
    def chunks(self) -> tuple[int, ...] | None: ...
    @chunks.setter
    def chunks(self, val: tuple[int, ...] | None): ...
    @property
    def compression(self) -> str | int | None: ...
    @compression.setter
    def compression(self, val: str | int | None): ...
    @property
    def compression_opts(self) -> dict[str, Any] | None: ...
    @compression_opts.setter
    def compression_opts(self, val: dict[str, Any] | None): ...
    def __getitem__(self, obj: SelectionLike) -> np.ndarray: ...
    def __setitem__(self, obj: SelectionLike, val: Any) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: Any) -> bool: ...

#
class MemDatasetDistributed(MemDataset):
    _data: MPIArray
    _chunks: tuple[int, ...] | None
    _compression: str | int | None
    _compression_opts: ClassVar[dict | None]
    def __init__(
        self,
        shape: tuple[int, ...],
        dtype: npt.DTypeLike,
        axis: int = 0,
        comm: MPI.Comm | None = None,
        chunks: tuple[int, ...] | None = None,
        compression: str | int | None = None,
        compression_opts: dict | None = None,
        **kwargs: Any,
    ) -> None: ...
    @classmethod
    def from_mpi_array(
        cls,
        data: MPIArray,
        chunks: tuple[int, ...] | None = None,
        compression: str | int | None = None,
        compression_opts: dict | None = None,
        **kwargs: Any,
    ) -> MemDatasetDistributed: ...
    @property
    def common(self) -> Literal[False]: ...
    @property
    def distributed(self) -> Literal[True]: ...
    @property
    def data(self) -> MPIArray: ...
    @property
    def local_data(self) -> np.ndarray: ...
    @property
    def shape(self) -> tuple[int, ...]: ...
    @property
    def global_shape(self) -> tuple[int, ...]: ...
    @property
    def local_shape(self) -> tuple[int, ...]: ...
    @property
    def local_offset(self) -> tuple[int, ...]: ...
    @property
    def dtype(self) -> np.dtype: ...
    @property
    def chunks(self) -> tuple[int, ...] | None: ...
    @chunks.setter
    def chunks(self, val: tuple[int, ...] | None): ...
    @property
    def compression(self) -> str | int | None: ...
    @compression.setter
    def compression(self, val: str | int | None): ...
    @property
    def compression_opts(self) -> dict[str, Any] | None: ...
    @compression_opts.setter
    def compression_opts(self, val: dict[str, Any] | None): ...
    @property
    def distributed_axis(self) -> int: ...
    @property
    def comm(self) -> MPI.Comm: ...
    def redistribute(self, axis: int) -> None: ...
    def __getitem__(self, obj: SelectionLike) -> np.ndarray: ...
    def __setitem__(self, obj: SelectionLike, val: npt.ArrayLike): ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: Any) -> bool: ...

#
class MemDiskGroup(_BaseGroup):
    _toclose: bool
    def __init__(
        self,
        data_group: FileOrGroupLike | None = None,
        distributed: bool = False,
        comm: MPI.Comm | None = None,
        file_format: FileFormat | None = None,
    ) -> None: ...
    def __enter__(self) -> MemDiskGroup: ...
    def __exit__(self, *args) -> None: ...
    @classmethod
    def _detect_subclass_path(cls, group: FileOrGroupLike) -> str | None: ...
    @classmethod
    def _resolve_subclass(cls, clspath: str | None) -> MemDiskGroup: ...
    @classmethod
    def from_group(
        cls, data_group: FileOrGroupLike | None = None, detect_subclass: bool = True
    ) -> MemDiskGroup: ...
    @property
    def _data(self) -> _StorageRoot: ...
    def _finish_setup(self) -> None: ...
    def close(self) -> None: ...
    def __getitem__(self, name: str) -> DatasetLike | GroupLike: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[str]: ...
    @property
    def ondisk(self) -> bool: ...
    @classmethod
    def _make_selections(cls, sel_args: dict[str | int, SelectionLike]) -> Mapping: ...
    _comm: MPI.Comm | None
    _lockfile: Incomplete
    @classmethod
    def from_file(
        cls,
        file_: FileOrGroupLike,
        ondisk: bool = False,
        distributed: bool = False,
        comm: MPI.Comm | None = None,
        detect_subclass: bool = True,
        convert_attribute_strings: bool | None = None,
        convert_dataset_strings: bool | None = None,
        file_format: FileFormat | None = None,
        **kwargs: Any,
    ) -> MemDiskGroup: ...
    @staticmethod
    def group_name_allowed(name: str) -> Literal[True]: ...
    @staticmethod
    def dataset_name_allowed(name: str) -> Literal[True]: ...
    def create_dataset(self, name: str, *args: Any, **kwargs: dict) -> DatasetLike: ...
    def dataset_common_to_distributed(
        self, name: str, distributed_axis: int = 0
    ) -> MemDatasetDistributed: ...
    def dataset_distributed_to_common(self, name: str) -> MemDatasetCommon: ...
    def create_group(self, name: str) -> GroupLike: ...
    def to_memory(self) -> MemDiskGroup: ...
    def to_disk(
        self, filename: str, file_format: FileFormat = ..., **kwargs: Any
    ) -> MemDiskGroup: ...
    def flush(self) -> None: ...
    def copy(self, shared: list[str] = [], shallow: bool = False) -> MemDiskGroup: ...
    def __deepcopy__(self, memo: Any, /) -> MemDiskGroup: ...
    def save(
        self,
        filename: str,
        convert_attribute_strings: bool | None = None,
        convert_dataset_strings: bool | None = None,
        file_format: FileFormat = ...,
        **kwargs: Any,
    ) -> None: ...

#
def attrs2dict(attrs: AttributesLike) -> dict: ...
def is_group(obj: Any) -> bool: ...
def get_h5py_File(
    f: FileOrGroupLike, **kwargs: Any
) -> tuple[FileOrGroupLike, bool]: ...
def get_file(f: FileOrGroupLike, file_format: FileFormat | None = None, **kwargs: Any):
    FileOrGroupLike

def copyattrs(
    a1: AttributesLike, a2: AttributesLike, convert_strings: bool = False
) -> None: ...

#
def deep_group_copy(
    g1: GroupLike,
    g2: GroupLike,
    selections: dict | None = None,
    convert_dataset_strings: bool = False,
    convert_attribute_strings: bool = True,
    file_format: FileFormat = ...,
    skip_distributed: bool = False,
    postprocess: Callable | None = None,
    shallow: bool = False,
    shared: Sequence[str] | None = None,
) -> list[str] | None: ...
def deep_copy_dataset(dset: Any, order: Literal["C", "F", "A", "K"] = "A") -> Any: ...
def format_abs_path(path: str) -> PathLike: ...

#
def _distributed_group_to_file(
    group: GroupLike,
    fname: PathLike,
    mode: str,
    hints: bool | dict = True,
    convert_dataset_strings: bool = False,
    convert_attribute_strings: bool = True,
    file_format: FileFormat | None = None,
    serial: bool = False,
    **kwargs: Any,
) -> None: ...
def _distributed_group_from_file(
    fname: PathLike,
    comm: MPI.Comm | None = None,
    hints: bool | dict = True,
    convert_dataset_strings: bool = False,
    convert_attribute_strings: bool = True,
    file_format: FileFormat = ...,
    **kwargs: Any,
) -> MemGroup: ...
